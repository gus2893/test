Schema Design
1. Main Table (R_Table)
This is  existing table.

Columns:
id: Unique ID for each row (primary key).
nego_date: Extracted nego_date from the JSON.
2. System_Info Table
Represents the first object (system) in the fc_i_ng array.

Columns:
id: Primary key (can reference R_Table.id as a foreign key or be independent).
r_id: Foreign key referencing R_Table.id.
s_i: System ID.
s_n: System Name.
3. Feature_Info Table
Represents each non-system object in the fc_i_ng array.

Columns:
id: Primary key.
r_id: Foreign key referencing R_Table.id.
e_t_i: Entity Type ID.
c_o: Company.
fac_e_i: Facility Entity ID.
fac_e_n: Facility Entity Name.
4. Target_Group Table
Represents each target group object in the arrays (t_g, t_f, t_m).

Columns:
id: Primary key.
feature_id: Foreign key referencing Feature_Info.id.
group_type: Indicates whether it's t_g, t_f, or t_m.
tmc: Target group code.
tmd: Target group description.
Workflow
1. Parse and Insert JSON Data
You will need to write scripts (e.g., using Python, SQL procedures, or ETL tools) to extract data from the JSON column and populate the normalized tables.

Extract nego_date from the JSON object and insert into R_Table:

sql
Copy code
UPDATE R_Table
SET nego_date = JSON_EXTRACT(json_column, '$.nego_date');
Insert system data into System_Info:

sql
Copy code
INSERT INTO System_Info (r_id, s_i, s_n)
SELECT id, 
       JSON_EXTRACT(json_column, '$.fc_i_ng[0].s_i'),
       JSON_EXTRACT(json_column, '$.fc_i_ng[0].s_n')
FROM R_Table;
Insert non-system data into Feature_Info:

sql
Copy code
INSERT INTO Feature_Info (r_id, e_t_i, c_o, fac_e_i, fac_e_n)
SELECT id, 
       JSON_EXTRACT(fc, '$.e_t_i'),
       JSON_EXTRACT(fc, '$.c_o'),
       JSON_EXTRACT(fc, '$.fac_e_i'),
       JSON_EXTRACT(fc, '$.fac_e_n')
FROM R_Table, JSON_TABLE(json_column, '$.fc_i_ng[*]' COLUMNS(
         fc JSON PATH '$'
     )) AS feature_table
WHERE JSON_EXTRACT(fc, '$.s_i') IS NULL; -- Exclude system objects
Insert target groups (t_g, t_f, t_m) into Target_Group:

sql
Copy code
INSERT INTO Target_Group (feature_id, group_type, tmc, tmd)
SELECT f.id, 't_g', tg.tmc, tg.tmd
FROM Feature_Info f
JOIN JSON_TABLE(f.json_column, '$.t_g[*]' COLUMNS(
         tmc VARCHAR(255) PATH '$.tmc',
         tmd VARCHAR(255) PATH '$.tmd'
     )) AS tg ON f.r_id = tg.r_id;

-- Repeat for `t_f` and `t_m` with 't_f' and 't_m' as `group_type`.
Queries
Find Rows with Specific c_o:
sql
Copy code
SELECT r.*
FROM R_Table r
JOIN Feature_Info f ON r.id = f.r_id
WHERE f.c_o = 'specific_company';
Count Rows with Specific s_i:
sql
Copy code
SELECT COUNT(*)
FROM R_Table r
JOIN System_Info s ON r.id = s.r_id
WHERE s.s_i = 'specific_system_id';
Count Rows with Specific fac_e_i:
sql
Copy code
SELECT COUNT(*)
FROM R_Table r
JOIN Feature_Info f ON r.id = f.r_id
WHERE f.fac_e_i = 'specific_fac_e_i';
Advantages of Normalization
Efficiency: Normalized tables reduce redundancy and make querying relationships easier and faster.
Flexibility: You can extend the schema for additional properties without modifying existing structure significantly.
Maintainability: Changes in one part of the schema do not propagate inconsistencies.
Let me know if you need help with SQL scripts, ETL processes, or tools to automate these steps!




dont worry about the target_group table we dont need it, its already defined, instead of making a new system_info table can we just add system as a part of the facility info
