Skip to content
Chat history

You said:
how would you create a paginated scroll filter for a react ag grid column
ChatGPT said:

Thought for 44 seconds
AG Grid’s built-in Set Filter doesn’t natively support paginated or infinite-scroll loading of the filter list—you either get all values at once or you supply them asynchronously in one go via filterParams.values 
ag-grid.com
. To get true “load more on scroll” behavior, you need to build a custom filter component in React that:

Manages its own paging state (current page, page size, total items).

Fetches each page of options from your API as the user scrolls.

Implements AG Grid’s filter interface (isFilterActive, doesFilterPass, getModel, setModel, etc.) so the grid knows when and how to filter rows 
ag-grid.com
.

1. Create the React filter component
import React, { useState, useEffect, useRef, useImperativeHandle, forwardRef, useCallback } from 'react';

interface PaginatedFilterProps {
  filterParams: { pageSize: number };
  valueGetter: (node: any) => string;
  filterChangedCallback: () => void;
}

const PaginatedFilter = forwardRef((props: PaginatedFilterProps, ref) => {
  const { pageSize } = props.filterParams;
  const [options, setOptions] = useState<Array<{ value: string; label: string }>>([]);
  const [page, setPage] = useState(0);
  const [selected, setSelected] = useState<Set<string>>(new Set());
  const [hasMore, setHasMore] = useState(true);
  const loader = useRef<HTMLDivElement>(null);

  // Fetch one page of options
  const loadPage = useCallback(() => {
    fetch(`/api/filterOptions?col=${props.valueGetter.name}&page=${page}&limit=${pageSize}`)
      .then(r => r.json())
      .then(({ items, totalCount }) => {
        setOptions(prev => [...prev, ...items]);
        if ((page + 1) * pageSize >= totalCount) setHasMore(false);
      });
  }, [page, pageSize, props.valueGetter]);

  useEffect(() => { loadPage(); }, [loadPage]);

  // Observe the “loader” div to trigger next page
  useEffect(() => {
    if (!loader.current || !hasMore) return;
    const obs = new IntersectionObserver(entries => {
      if (entries[0].isIntersecting) setPage(p => p + 1);
    }, { root: loader.current.parentElement, threshold: 1.0 });
    obs.observe(loader.current);
    return () => obs.disconnect();
  }, [hasMore]);

  // AG Grid filter interface
  useImperativeHandle(ref, () => ({
    // Active if any option is selected
    isFilterActive: () => selected.size > 0,
    // Test each row against selected values
    doesFilterPass: params => selected.has(props.valueGetter(params.node)),
    // What AG Grid will store/apply
    getModel: () => selected.size ? { values: Array.from(selected) } : null,
    // When restoring filter state
    setModel: model => {
      setSelected(new Set(model?.values || []));
    },
    // No special focus handling needed
    afterGuiAttached: () => {}
  }));

  const onToggle = (val: string) => {
    setSelected(s => {
      const next = new Set(s);
      next.has(val) ? next.delete(val) : next.add(val);
      return next;
    });
    props.filterChangedCallback();
  };

  return (
    <div style={{ height: '200px', overflow: 'auto' }}>
      {options.map(opt => (
        <label key={opt.value} style={{ display: 'block' }}>
          <input
            type="checkbox"
            checked={selected.has(opt.value)}
            onChange={() => onToggle(opt.value)}
          />{' '}
          {opt.label}
        </label>
      ))}
      {hasMore && <div ref={loader} style={{ height: '1px' }} />}
    </div>
  );
});
We fetch page 0 on mount, then increment page whenever the “loader” sentinel scrolls into view 
ag-grid.com
.

isFilterActive/doesFilterPass let AG Grid know when to include a row.

getModel/setModel handle serializing and restoring the filter state.

2. Hook it into your column definition
<AgGridReact
  columnDefs={[
    {
      field: 'status',
      headerName: 'Status',
      filter: PaginatedFilter,            // use our custom component
      filterParams: { pageSize: 50 },     // number of options per “page”
      valueGetter: node => node.data.status // how to extract the raw value
    },
    /* other columns… */
  ]}
  /* other grid props… */
/>
By specifying filter: PaginatedFilter, AG Grid will render your component in the column’s filter popup.

filterParams.pageSize controls how many options you fetch per request.

3. Benefits & tweaks
Server-side heavy lists: You never load thousands of values at once—just what’s needed for the current viewport.

Easy to extend: Add a “mini-filter” search box above the list and re-query your endpoint with a search parameter.

Styling & virtualization: Swap the plain scroll+IntersectionObserver for a virtualized list (e.g. react-window) if you want smooth performance on very large option sets.

This pattern gives you full control over pagination, searching, and rendering within the filter UI—exactly what you need for a “paginated scroll” experience in React + AG Grid.




No file chosenNo file chosen
ChatGPT can make mistakes. Check important info.
